# -*- coding: utf-8 -*-
"""seating.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UPtqJ_xHkH_KLxYwFJxBCgiBLfQNeSz2
"""

import torch
import torch.nn as nn
import torch.optim as optim
import numpy as np
import random

# Generate conflict matrices
list_of_conflicts = []

while len(list_of_conflicts) < 500:
    pairs_list = set()
    matrix = np.zeros((24, 24), dtype=int)

    while matrix.sum() < 40:
        num1 = np.random.choice(range(24))
        num2 = np.random.choice(range(24))

        if num1 == num2:
            continue

        pair = (num1, num2)
        if pair in pairs_list:
            continue

        pairs_list.add(pair)
        matrix[num1, num2] = 1

    if not any(np.array_equal(matrix, conflict) for conflict in list_of_conflicts):
        list_of_conflicts.append(matrix)


conflicts = np.array(list_of_conflicts)

def create_adjacent_mask(n_seats, seats_per_row, seats_per_col):
    adjacent_mask = np.zeros((n_seats, n_seats))
    for i in range(n_seats):
        if i % seats_per_row != 0:
            adjacent_mask[i, i-1] = 1
        if i % seats_per_row != seats_per_row-1:
            adjacent_mask[i, i+1] = 1
        if i >= seats_per_row:
            adjacent_mask[i, i-seats_per_row] = 1
        if i < n_seats-seats_per_row:
            adjacent_mask[i, i+seats_per_row] = 1
    return adjacent_mask

adjacent_mask = create_adjacent_mask(24, 6, 4)
adjacent_mask = torch.tensor(adjacent_mask, dtype=torch.float32)


def calculate_conflict(seating_arrangement, conflict_matrix):
    ca_mul = conflict_matrix * adjacent_mask
    conflicts = torch.sum(torch.matmul(seating_arrangement, ca_mul))
    return conflicts

def custom_loss(predicted_seating_arrangement, conflicts_tensor):
    loss = 0
    for i in range(predicted_seating_arrangement.shape[0]):
        conflict = calculate_conflict(predicted_seating_arrangement[i], conflicts_tensor[i])

        occurrences = torch.sum(predicted_seating_arrangement[i], dim=0)


        repetitive_elements = torch.sum(torch.abs(occurrences - 1)) / 24

        loss += repetitive_elements + conflict
    return loss / predicted_seating_arrangement.shape[0]

conflicts_tensor = torch.tensor(conflicts, dtype=torch.float32)  # Use float32

# Define the neural network
class ConflictModel(nn.Module):
    def __init__(self):
        super(ConflictModel, self).__init__()
        self.flatten = nn.Flatten()
        self.fc1 = nn.Linear(24*24, 10)
        self.fc2 = nn.Linear(10, 24*24)
        self.softmax = nn.Softmax(dim=1)

    def forward(self, x):
        x = self.flatten(x)
        x = torch.relu(self.fc1(x))
        x = self.softmax(self.fc2(x))
        x = x.view(-1, 24, 24)
        return x

model = ConflictModel()

optimizer = optim.Adam(model.parameters(), lr=0.01)

for epoch in range(10):
    model.train()
    optimizer.zero_grad()
    predicted_seating_arrangement = model(conflicts_tensor)
    loss = custom_loss(predicted_seating_arrangement, conflicts_tensor)
    loss.backward()
    optimizer.step()

    print(f'Epoch: {epoch}, Loss: {loss.item()}')

    print(f'Predicted Seating Arrangement for Epoch {epoch}:')
    print(predicted_seating_arrangement.detach().numpy())